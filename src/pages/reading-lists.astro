---
import Layout from "../layouts/Layout.astro";
import FormattedEntry from "../components/FormattedEntry.astro";
import rawList from "../data/reading-list.txt?raw";

import type { BookEntry } from "../types";

const crumbs = [
  {
    name: "home",
    link: "/",
    disabled: false,
  },
  {
    name: "Reading Lists",
    link: "/reading-lists",
    disabled: true,
  },
];

function prettifyPascalCase(token: string | null): string | null {
  if (!token) return null;
  return token
    .replace(/\.([A-Z])/g, ". $1")
    .replace(/([a-z])([A-Z])/g, "$1 $2")
    .replace(/\s+/g, " ")
    .trim();
}

const entries: BookEntry[] = rawList
  .split("\n")
  .filter((line) => line.trim())
  .filter(Boolean)
  .map((line) => {
    let working = line.trim();

    // --- Extract status ---
    const statusMatch = working.match(/\(([^)]+)\)/);
    const status = statusMatch ? statusMatch[1] : "unknown";
    if (statusMatch) working = working.replace(statusMatch[0], "").trim();

    // --- Extract series ---
    const seriesMatch = working.match(/\+(\S+)/);
    let series = seriesMatch ? seriesMatch[1] : null;
    if (seriesMatch) working = working.replace(seriesMatch[0], "").trim();
    series = prettifyPascalCase(series);

    // --- Extract number ---
    const numberMatch = working.match(/#\S+/);
    const number = numberMatch ? numberMatch[0] : null;
    if (numberMatch) working = working.replace(numberMatch[0], "").trim();

    // --- Extract author ---
    const authorMatch = working.match(/--\s*(\S+)/);
    let author: string | null = null;
    if (authorMatch) {
      author = prettifyPascalCase(authorMatch[1]);
      working = working.replace(authorMatch[0], "").trim();
    }

    // --- Extract tags ---
    const tags = [...working.matchAll(/@\w+/g)].map((m) => m[0]);
    if (tags.length > 0) {
      tags.forEach((t) => {
        working = working.replace(t, "").trim();
      });
    }

    // --- Remaining text is title ---
    const title = working.trim();

    return { status, series, number, title, author, tags };
  });

const current: BookEntry[] = entries.filter(
  (entery) => entery.status == "current"
);

const awaited: BookEntry[] = entries.filter(
  (entry) => entry.status == "awaited"
);

const finished: BookEntry[] = entries.filter((entry) => entry.status == "read");

const cancelled: BookEntry[] = entries.filter(
  (entry) => entry.status == "cancelled"
);

function groupAndSortBySeries(entries: BookEntry[]) {
  return entries.slice().sort((a, b) => {
    // Same series â†’ sort by number
    if (a.series && b.series && a.series === b.series) {
      if (a.number && b.number) {
        return parseFloat(a.number.slice(1)) - parseFloat(b.number.slice(1));
      } else if (a.number) {
        return -1;
      } else if (b.number) {
        return 1;
      }
      return 0;
    }

    if (a.series && !b.series) return -1;
    if (!a.series && b.series) return 1;

    if (a.series && b.series) return a.series.localeCompare(b.series);
    return a.title.localeCompare(b.title);
  });
}

const currentSorted = groupAndSortBySeries(current);
const awaitedSorted = groupAndSortBySeries(awaited);
const finishedSorted = groupAndSortBySeries(finished);
const cancelledSorted = groupAndSortBySeries(cancelled);
---

<Layout title="reading lists" crumbs={crumbs}>
  <h1 class="title" id="title">Reading Lists</h1>
  <p>
    Following are my reading lists, the lists are sorted alphabetically, and
    series are sorted first to make sure all enteries of a series will be
    grouped together, I say reading, but I mostly do listening as audiobooks are
    my favorite way to consume books. The lists are as follows:
  </p>
  <ul class="page-nav">
    <li><a href="#current">Currently reading</a></li>
    <li><a href="#awaited">Awaited</a></li>
    <li><a href="#read">Finished</a></li>
    <li><a href="#cancelled">Cancelled</a></li>
  </ul>

  <h2 class="subtitle" id="current">Currently reading</h2>
  <p>
    Books that I am currently reading, though I mostly focus on one book more
    than the others, I still do read more than one book at a time.
  </p>
  <ul>
    {currentSorted.map((entry: BookEntry) => <FormattedEntry entry={entry} />)}
  </ul>
  <h2 class="subtitle" id="awaited">Awaited</h2>
  <p>
    books that are either in queue or I am interesting in reading at a later
    time
  </p>
  <ul>
    {awaitedSorted.map((entry: BookEntry) => <FormattedEntry entry={entry} />)}
  </ul>
  <h2 class="subtitle" id="read">Finished</h2>
  <p>
    Books that I have finished reading, the following are the once I do
    rememeber.
  </p>
  <ul>
    {finishedSorted.map((entry: BookEntry) => <FormattedEntry entry={entry} />)}
  </ul>
  <h2 class="subtitle" id="cancelled">Cancelled</h2>
  <p>
    Books that I have not finished reading, and I am not interested in finishing
    at all.
  </p>
  <ul>
    {
      cancelledSorted.map((entry: BookEntry) => (
        <FormattedEntry entry={entry} />
      ))
    }
  </ul>
</Layout>

<style>
  p {
    max-width: 50ch;
  }

  [data-icon] {
    color: var(--tertiary);
  }
</style>
