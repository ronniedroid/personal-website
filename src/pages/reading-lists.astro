---
import Layout from "../layouts/Layout.astro";
import FormattedEntry from "../components/FormattedEntry.astro";
import rawList from "../data/reading-list.txt?raw";

import type { BookEntry } from "../types";

const crumbs = [
  {
    name: "home",
    link: "/",
    disabled: false,
  },
  {
    name: "Reading Lists",
    link: "/reading-lists",
    disabled: true,
  },
];

const entries: BookEntry[] = rawList
  .split("\n")
  .filter((line) => line.trim().length > 0)
  .map((line) => {
    const statusMatch = line.match(/^\((.*?)\)/);
    const status = statusMatch ? statusMatch[1] : "unknown";

    const tags = [...line.matchAll(/@\w+/g)].map((m) => m[0]);

    const [beforeAuthor, afterAuthor] = line.split("--");
    const author = afterAuthor ? afterAuthor.split("@")[0].trim() : "";

    const seriesPattern = /^\+(\S+)\s+(#\S+)?\s*(.*)$/;
    const seriesMatch = beforeAuthor
      .replace(/^\(.*?\)\s*/, "")
      .match(seriesPattern);

    let series: string | null = null;
    let number: string | null = null;
    let title: string = "";

    if (seriesMatch) {
      series = seriesMatch[1];
      number = seriesMatch[2] || null;
      title = seriesMatch[3].trim();
    } else {
      title = beforeAuthor.replace(/^\(.*?\)\s*/, "").trim();
    }

    return { status, series, number, title, author, tags };
  });

const current: BookEntry[] = entries.filter(
  (entery) => entery.status == "current"
);

const awaited: BookEntry[] = entries.filter(
  (entry) => entry.status == "awaited"
);

const finished: BookEntry[] = entries.filter((entry) => entry.status == "read");

const cancelled: BookEntry[] = entries.filter(
  (entry) => entry.status == "cancelled"
);

function groupAndSortBySeries(entries: BookEntry[]) {
  return entries.slice().sort((a, b) => {
    // Same series → sort by number
    if (a.series && b.series && a.series === b.series) {
      if (a.number && b.number) {
        return parseFloat(a.number.slice(1)) - parseFloat(b.number.slice(1));
      } else if (a.number) {
        return -1;
      } else if (b.number) {
        return 1;
      }
      return 0; // no number, keep original order
    }

    // Otherwise, group series first
    if (a.series && !b.series) return -1;
    if (!a.series && b.series) return 1;

    // Different series → alphabetical by series
    if (a.series && b.series) return a.series.localeCompare(b.series);

    // Neither has series → alphabetical by title
    return a.title.localeCompare(b.title);
  });
}

// Apply after filtering by status
const currentSorted = groupAndSortBySeries(current);
const awaitedSorted = groupAndSortBySeries(awaited);
const finishedSorted = groupAndSortBySeries(finished);
const cancelledSorted = groupAndSortBySeries(cancelled);
---

<Layout title="reading lists" crumbs={crumbs}>
  <h1 class="title" id="title">Reading Lists</h1>
  <p>
    Following are my reading lists, the lists are sorted alphabetically, and
    series are sorted first to make sure all enteries of a series will be
    grouped together, I say reading, but I mostly do listening as audiobooks are
    my favorite way to consume books. The lists are as follows:
  </p>
  <ul class="page-nav">
    <li><a href="#current">Currently reading</a></li>
    <li><a href="#awaited">Awaited</a></li>
    <li><a href="#read">Finished</a></li>
    <li><a href="#cancelled">Cancelled</a></li>
  </ul>

  <h2 class="subtitle" id="current">Currently reading</h2>
  <p>
    Books that I am currently reading, though I mostly focus on one book more
    than the others, I still do read more than one book at a time.
  </p>
  <ul>
    {currentSorted.map((entry: BookEntry) => <FormattedEntry entry={entry} />)}
  </ul>
  <h2 class="subtitle" id="awaited">Awaited</h2>
  <p>
    books that are either in queue or I am interesting in reading at a later
    time
  </p>
  <ul>
    {awaitedSorted.map((entry: BookEntry) => <FormattedEntry entry={entry} />)}
  </ul>
  <h2 class="subtitle" id="read">Finished</h2>
  <p>
    Books that I have finished reading, the following are the once I do
    rememeber.
  </p>
  <ul>
    {finishedSorted.map((entry: BookEntry) => <FormattedEntry entry={entry} />)}
  </ul>
  <h2 class="subtitle" id="cancelled">Cancelled</h2>
  <p>
    Books that I have not finished reading, and I am not interested in finishing
    at all.
  </p>
  <ul>
    {
      cancelledSorted.map((entry: BookEntry) => (
        <FormattedEntry entry={entry} />
      ))
    }
  </ul>
</Layout>

<style>
  p {
    max-width: 50ch;
  }

  [data-icon] {
    color: var(--tertiary);
  }
</style>
